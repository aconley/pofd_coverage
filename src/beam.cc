//beam.cc

#include<sstream>

#include "../include/beam.h"
#include "../include/global_settings.h"
#include "../include/pofdExcept.h"

/*!
  \param[in] FWHM     FWHM of beam, in arcsec
*/
beam::beam( double FWHM ) { setFWHM(FWHM); }

/*!
  \param[in] fwhm_    New FWHM of beam, in arcsec
*/
void beam::setFWHM(double fwhm_) {
  fwhm = fwhm_;
  rhosq = pofd_coverage::rhofac / (fwhm*fwhm);
}

double beam::getEffectiveArea() const {
  return pofd_coverage::pi / rhosq;
}

double beam::getEffectiveAreaSq() const {
  return 0.5*pofd_coverage::pi / rhosq;
}

/*!
  \param[in] n  Number of pixels along each dimension.  Should be odd
  \param[in] pixsize Size of pixels in arcsec
  \param[out] fac Returns beam factor.  Must be pre-allocated by
                   caller and be of length n

  The beam is center normalized.  Filtering is not supported.	     
 */
void beam::getBeamFac(unsigned int n, double pixsize,
		      double* const fac) const {

  //Input checks
  if (n == 0) {
    std::stringstream errstr;
    errstr << "n (" << n << ") should be positive";
    throw pofdExcept("beam", "getBeamFac", errstr.str(), 1);
  }
  if (n % 2 == 0) {
    std::stringstream errstr;
    errstr << "n (" << n << ") should be odd";
    throw pofdExcept("beam", "getBeamFac", errstr.str(), 2);
  }
  if (pixsize <= 0.0) {
    std::stringstream errstr;
    errstr << "pixsize (" << pixsize << ") should be positive";
    throw pofdExcept("beam", "getBeamFac", errstr.str(), 3);
  }
  if (fac == NULL)
    throw pofdExcept("beam", "getBeamFac", "fac is not allocated", 4);

  if (n == 1) {
    fac[0] = 1.0;
    return;
  }

  double sig = fwhm * pofd_coverage::fwhmfac / pixsize; //Gaussian sigma in pix
  double expfac = - 0.5 / (sig * sig);
  int ni = static_cast<int>(n);
  int no2 = ni / 2;
  double dist;
  for (int i = 0; i < ni; ++i) {
    dist = fabs(i - no2);
    fac[i] = exp(expfac * dist * dist);
  }
}


/*!
  \param[in] n  Number of pixels along each dimension.  Should be odd
  \param[in] pixsize Size of pixels in arcsec
  \param[out] bm Returns beam in row-major order.  Must be pre-allocated by
                   caller and be of length n * n

  The beam is center normalized.  Filtering not supported	     
 */
void beam::getRawBeam(unsigned int n, double pixsize,
		      double* const bm) const {

  //Input checks
  if (n == 0) {
    std::stringstream errstr;
    errstr << "n (" << n << ") should be positive";
    throw pofdExcept("beam", "getRawBeam", errstr.str(), 1);
  }
  if (n % 2 == 0) {
    std::stringstream errstr;
    errstr << "n (" << n << ") should be odd";
    throw pofdExcept("beam", "getRawBeam", errstr.str(), 2);
  }
  if (pixsize <= 0.0) {
    std::stringstream errstr;
    errstr << "pixsize (" << pixsize << ") should be positive";
    throw pofdExcept("beam", "getRawBeam", errstr.str(), 3);
  }
  if (bm == NULL)
    throw pofdExcept("beam", "getRawBeam", "bm is not allocated", 4);

  if (n == 1) {
    bm[0] = 1.0;
    return;
  }

  //Make factorized beam, then multiply
  double* fac = new double[n];
  double sig = fwhm * pofd_coverage::fwhmfac / pixsize; //Gaussian sigma in pix
  double expfac = - 0.5 / (sig * sig);
  int ni = static_cast<int>(n);
  int no2 = ni / 2;
  double dist;
  for (int i = 0; i < ni; ++i) {
    dist = fabs(i - no2);
    fac[i] = exp(expfac * dist * dist);
  }

  double val;
  double* rowptr;
  for (unsigned int i = 0; i < n; ++i) {
    val = fac[i];
    rowptr = bm + i * n;
    for (unsigned int j = 0; j < n; ++j)
      rowptr[j] = val * fac[j];
  }

  delete[] fac;
}


/*!
  \param[in] n  Number of pixels along each dimension.  Should be odd
  \param[in] pixsize Size of pixels in arcsec
  \param[in] oversamp Oversampling.  Must be odd
  \param[out] bm Returns beam in row-major order.  Must be pre-allocated by
                   caller and be of length n * n

  The beam is center normalized.  Note that the returned beam is
  always at the nominal sampling.  It's just that if oversampling is
  used this is generated by making a more finely sampled one and then
  repixelating.

  Filtering is not supported
 */
void beam::getRawBeam(unsigned int n, double pixsize, unsigned int oversamp,
		      double* const bm) const {

  //Quick return
  if (oversamp == 1) {
    getRawBeam(n, pixsize, bm);
    return;
  }

  //Input checks
  if (n == 0) {
    std::stringstream errstr;
    errstr << "n (" << n << ") should be positive";
    throw pofdExcept("beam", "getRawBeam", errstr.str(), 1);
  }
  if (n % 2 == 0) {
    std::stringstream errstr;
    errstr << "n (" << n << ") should be odd";
    throw pofdExcept("beam", "getRawBeam", errstr.str(), 2);
  }
  if (pixsize <= 0.0) {
    std::stringstream errstr;
    errstr << "pixsize (" << pixsize << ") should be positive";
    throw pofdExcept("beam", "getRawBeam", errstr.str(), 3);
  }
  if (oversamp == 0) {
    std::stringstream errstr;
    errstr << "oversampling (" << oversamp << ") should be positive";
    throw pofdExcept("beam", "getRawBeam", errstr.str(), 4);
  }
  if (oversamp % 2 == 0) {
    std::stringstream errstr;
    errstr << "oversampling (" << oversamp << ") should be odd";
    throw pofdExcept("beam", "getRawBeam", errstr.str(), 5);
  }
  if (bm == NULL)
    throw pofdExcept("beam", "getRawBeam", "bm is not allocated", 6);

  //Make factorized beam, then multiply and sum
  unsigned int ngen = oversamp * n;
  double pixgen = pixsize / static_cast<double>(oversamp);
  double* fac = new double[ngen];
  double sig = fwhm * pofd_coverage::fwhmfac / pixgen; //Gaussian sigma in pix
  double expfac = - 0.5 / (sig * sig);
  int ni = static_cast<int>(ngen);
  int no2 = ni / 2;
  double dist;
  double normfac = 1.0 / static_cast<double>(oversamp);
  for (int i = 0; i < ni; ++i) {
    dist = fabs(i - no2);
    fac[i] = normfac * exp(expfac * dist * dist);
  }

  // Zero out
  for (unsigned int i = 0; i < n * n; ++i)
    bm[i] = 0.0;

  // Form the sum
  double val;
  double* rowptr;
  unsigned int minip, maxip, minjp, maxjp;
  for (unsigned int i = 0; i < n; ++i) {
    rowptr = bm + i * n;
    minip = i * oversamp;
    maxip = minip + oversamp;
    for (unsigned int i_p = minip; i_p < maxip; ++i_p) {
      val = fac[i_p];
      for (unsigned int j = 0; j < n; ++j) {
	minjp = j * oversamp;
	maxjp = minjp + oversamp;
	for (unsigned int j_p = minjp; j_p < maxjp; ++j_p)
	  rowptr[j] += val * fac[j_p];
      }
    }
  }

  delete[] fac;
}

/*!
  \param[in] n  Number of pixels along each dimension.  Should be odd
  \param[in] pixsize Size of pixels in arcsec
  \param[in] bmpos Beam. Must be pre-allocated by
                   caller and be of length n * n
  \param[in] filterparam Filter parameter.  If 0, no filtering		   

  The beam is center normalized.  Note that all spatial information is
  lost by splitting into neg/pos parts
 */
void beam::getBeam(unsigned int n, double pixsize, double* const bm, 
		   double filterparam) const {

  // pre-filtered beam
  getRawBeam(n, pixsize, bm);

  // Apply filtering
  if (filterparam != 0)
    throw pofdExcept("beam", "getBeamHist", 
		     "Filtering not implemented", 2);
}


/*!
  \param[in] n  Number of pixels along each dimension.  Should be odd
  \param[in] pixsize Size of pixels in arcsec
  \param[in] oversamp Oversampling.  Must be odd
  \param[in] bm Beam. Must be pre-allocated by
                   caller and be of length n * n
  \param[in] filterparam Filter parameter.  If 0, no filtering is applied

  The beam is center normalized.  
*/
void beam::getBeam(unsigned int n, double pixsize, unsigned int oversamp,
		   double* const bm, double filterparam) const {

  // Pre-filtered beam
  getRawBeam(n, pixsize, oversamp, bm);

  // Apply filtering
  if (filterparam != 0)
    throw pofdExcept("beam", "getBeam", 
		     "Filtering not implemented", 1);
}

/*!
  \param[in] n  Number of pixels along each dimension.  Should be odd
  \param[in] pixsize Size of pixels in arcsec
  \param[in] nbins Number of bins of output
  \param[in] npos Number of nonzero positive beam histogram elements.
  \param[in] wtpos Weights for positive beam.
  \param[in] bmpos Positive part of beam histogram. Must be pre-allocated by
                   caller and be of length nbins
  \param[in] nneg Number of nonzero negative beam histogram elements.
                  Will be zero if no filtering.
  \param[in] wtneg Weights for negative beam.
  \param[in] bmneg Negative part of beam histogram. Must be pre-allocated by
                   caller and be of length nbins
  \param[in] filterparam Filter parameter.  No filtering if set to 0.
  \param[in] inverse If set, return one over the beam (for non-zero entries)

  The beam is center normalized.  The non-zero entries of the weights
  and beams are shuffled to the front.  The additional entries are not
  set to zero.
*/
void beam::getBeamHist(unsigned int n, double pixsize,
		       unsigned int nbins, unsigned int& npos, 
		       unsigned int* const wtpos, double* const bmpos,
		       unsigned int& nneg, unsigned int* const wtneg, 
		       double* const bmneg, double filterparam,
		       bool inverse) const {
  getBeamHist(n, pixsize, nbins, 1, npos, wtpos, bmpos,
	      nneg, wtneg, bmneg, filterparam, inverse);
}

/*!
  \param[in] n  Number of pixels along each dimension.  Should be odd
  \param[in] pixsize Size of pixels in arcsec
  \param[in] nbins Number of bins of output
  \param[in] oversamp Oversampling.  Must be odd
  \param[in] npos Number of nonzero positive beam histogram elements.
  \param[in] wtpos Weights for positive beam.
  \param[in] bmpos Positive part of beam histogram. Must be pre-allocated by
                   caller and be of length nbins
  \param[in] nneg Number of nonzero negative beam histogram elements.
                  Will be zero if no filtering.
  \param[in] wtneg Weights for negative beam.
  \param[in] bmneg Negative part of beam histogram. Must be pre-allocated by
                   caller and be of length nbins
  \param[in] filterparam Filter parameter.  No filtering if set to 0
  \param[in] inverse If set, return one over the beam (for non-zero entries)

  The beam is center normalized.  The non-zero entries of the weights
  and beams are shuffled to the front.  The additional entries are not
  set to zero.
 */
void beam::getBeamHist(unsigned int n, double pixsize, unsigned int nbins, 
		       unsigned int oversamp, unsigned int& npos, 
		       unsigned int* const wtpos, double* const bmpos,
		       unsigned int& nneg, unsigned int* const wtneg, 
		       double* const bmneg, double filterparam,
		       bool inverse) const {
  
  const double minval = 1e-5; //Always ignore beam values below this

  // We can't be as cute here as for the non-filtered beam, because
  // filtering more or less needs access to the real beam.  So...
  // just proceed via brute force.
  if (n == 0) {
    std::stringstream errstr;
    errstr << "n (" << n << ") should be positive";
    throw pofdExcept("beam", "getBeamHist", errstr.str(), 1);
  }
  double* bmtmp = new double[n * n];
  getRawBeam(n, pixsize, oversamp, bmtmp);

  // Apply filtering
  if (filterparam != 0)
    throw pofdExcept("beam", "getBeamHist", 
		     "Filtering not implemented", 2);

  // Find minimum and maximum non-zero parts for neg/pos histograms
  bool has_pos = false;
  bool has_neg = false;
  double minbinval_pos, maxbinval_pos, minbinval_neg, maxbinval_neg;
  minbinval_pos = minbinval_neg = 1e100; // Will definitely never be this large
  maxbinval_pos = maxbinval_neg = -1.0;
  double val;
  for (unsigned int i = 0; i < n * n; ++i) {
    val = bmtmp[i];
    // Ignore anything within [-minval, minval]
    if (val > minval) {
      has_pos = true;
      if (val > maxbinval_pos) maxbinval_pos = val;
      if (val < minbinval_pos) minbinval_pos = val;
    } else if (val < -minval) {
      val = fabs(val);
      has_neg = true;
      if (val > maxbinval_neg) maxbinval_neg = val;
      if (val < minbinval_neg) minbinval_neg = val;
    }
  }

  double histstep_pos, histstep_neg;
  if (has_pos) {
    minbinval_pos = log2(0.999 * minbinval_pos);
    maxbinval_pos = log2(1.001 * maxbinval_pos);
    histstep_pos = (maxbinval_pos - minbinval_pos) / static_cast<double>(nbins);
  }
  if (has_neg) {
    minbinval_neg = log2(0.999 * minbinval_neg);
    maxbinval_neg = log2(1.001 * maxbinval_neg);
    histstep_neg = (maxbinval_neg - minbinval_neg) / static_cast<double>(nbins);
  }

  // Histogram
  unsigned int idx, utmp;
  unsigned int *tmpwt;
  tmpwt = new unsigned int[nbins];
  double *tmphist;
  tmphist = new double[nbins];

  // Positive histogram
  npos = 0;
  double lval;
  if (has_pos) {
    for (unsigned int i = 0; i < nbins; ++i)
      tmpwt[i] = 0;
    for (unsigned int i = 0; i < nbins; ++i)
      tmphist[i] = 0.0;
    for (unsigned int i = 0; i < n * n; ++i) {
      val = bmtmp[i];
      lval = log2(val);
      if (lval < minbinval_pos) {
	idx = static_cast<unsigned int>((lval - minbinval_pos) / 
					histstep_pos);
	tmphist[idx] += val;
	tmpwt[idx] += 1;
      }
    }
    for (unsigned int i = 0; i < nbins; ++i)
      if (tmpwt[i] > 0) ++npos;
    // Shuffle all the filled bins to the front
    idx = 0;
    for (unsigned int i = 0; i < nbins; ++i) {
      utmp = tmpwt[i];
      if (utmp > 0) {
	wtpos[idx] = utmp;
	bmpos[idx] = tmphist[i] / static_cast<double>(utmp);
	++idx;
      }
    }
    if (inverse)
      for (unsigned int i = 0; i < npos; ++i)
	bmpos[i] = 1.0 / bmpos[i];
  }

  // Negative
  nneg = 0;
  if (has_neg) {
    for (unsigned int i = 0; i < nbins; ++i)
      tmpwt[i] = 0;
    for (unsigned int i = 0; i < nbins; ++i)
      tmphist[i] = 0.0;
    for (unsigned int i = 0; i < n * n; ++i) {
      val = fabs(bmtmp[i]);
      lval = log2(val);
      if (lval < minbinval_neg) {
	idx = static_cast<unsigned int>((lval - minbinval_neg) / 
					histstep_neg);
	tmphist[idx] += val;
	tmpwt[idx] += 1;
      }
    }
    for (unsigned int i = 0; i < nbins; ++i)
      if (tmpwt[i] > 0) ++nneg;
    // Shuffle all the filled bins to the front
    idx = 0;
    for (unsigned int i = 0; i < nbins; ++i) {
      utmp = tmpwt[i];
      if (utmp > 0) {
	wtneg[idx] = utmp;
	bmneg[idx] = tmphist[i] / static_cast<double>(utmp);
	++idx;
      }
    }
    if (inverse)
      for (unsigned int i = 0; i < nneg; ++i)
	bmneg[i] = 1.0 / bmneg[i];
  }

  // Clean up
  delete[] tmpwt;
  delete[] tmphist;
  delete[] bmtmp;
}

