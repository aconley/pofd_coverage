//beam.cc

#include<sstream>
#include<limits>

#include "../include/beam.h"
#include "../include/global_settings.h"
#include "../include/pofdExcept.h"

/*!
  \param[in] FWHM     FWHM of beam, in arcsec
*/
beam::beam(double FWHM) { setFWHM(FWHM); }

/*!
  \param[in] fwhm_    New FWHM of beam, in arcsec
*/
void beam::setFWHM(double fwhm_) {
  fwhm = fwhm_;
  rhosq = pofd_coverage::rhofac / (fwhm*fwhm);
}

double beam::getEffectiveArea() const {
  return pofd_coverage::pi / rhosq;
}

double beam::getEffectiveAreaSq() const {
  return 0.5 * pofd_coverage::pi / rhosq;
}

/*!
  \param[in] n  Number of pixels along each dimension.  Should be odd
  \param[in] pixsize Size of pixels in arcsec
  \param[out] fac Returns beam factor.  Must be pre-allocated by
                   caller and be of length n

  The beam is center normalized.  Filtering is not supported.	     
 */
void beam::getBeamFac(unsigned int n, double pixsize,
		      double* const fac) const {

  //Input checks
  if (n == 0) {
    std::stringstream errstr;
    errstr << "n (" << n << ") should be positive";
    throw pofdExcept("beam", "getBeamFac", errstr.str(), 1);
  }
  if (n % 2 == 0) {
    std::stringstream errstr;
    errstr << "n (" << n << ") should be odd";
    throw pofdExcept("beam", "getBeamFac", errstr.str(), 2);
  }
  if (pixsize <= 0.0) {
    std::stringstream errstr;
    errstr << "pixsize (" << pixsize << ") should be positive";
    throw pofdExcept("beam", "getBeamFac", errstr.str(), 3);
  }
  if (fac == NULL)
    throw pofdExcept("beam", "getBeamFac", "fac is not allocated", 4);

  if (n == 1) {
    fac[0] = 1.0;
    return;
  }

  double sig = fwhm * pofd_coverage::fwhmfac / pixsize; //Gaussian sigma in pix
  double expfac = - 0.5 / (sig * sig);
  int ni = static_cast<int>(n);
  int no2 = ni / 2;
  double dist;
  for (int i = 0; i < ni; ++i) {
    dist = fabs(i - no2);
    fac[i] = exp(expfac * dist * dist);
  }
}


/*!
  \param[in] n  Number of pixels along each dimension.  Should be odd
  \param[in] pixsize Size of pixels in arcsec
  \param[out] bm Returns beam in row-major order.  Must be pre-allocated by
                   caller and be of length n * n

  The beam is center normalized.  Filtering not supported	     
 */
void beam::getRawBeam(unsigned int n, double pixsize,
		      double* const bm) const {

  //Input checks
  if (n == 0) {
    std::stringstream errstr;
    errstr << "n (" << n << ") should be positive";
    throw pofdExcept("beam", "getRawBeam", errstr.str(), 1);
  }
  if (n % 2 == 0) {
    std::stringstream errstr;
    errstr << "n (" << n << ") should be odd";
    throw pofdExcept("beam", "getRawBeam", errstr.str(), 2);
  }
  if (pixsize <= 0.0) {
    std::stringstream errstr;
    errstr << "pixsize (" << pixsize << ") should be positive";
    throw pofdExcept("beam", "getRawBeam", errstr.str(), 3);
  }
  if (bm == NULL)
    throw pofdExcept("beam", "getRawBeam", "bm is not allocated", 4);

  if (n == 1) {
    bm[0] = 1.0;
    return;
  }

  //Make factorized beam, then multiply
  double* fac = new double[n];
  double sig = fwhm * pofd_coverage::fwhmfac / pixsize; //Gaussian sigma in pix
  double expfac = - 0.5 / (sig * sig);
  int ni = static_cast<int>(n);
  int no2 = ni / 2;
  double dist;
  for (int i = 0; i < ni; ++i) {
    dist = fabs(i - no2);
    fac[i] = exp(expfac * dist * dist);
  }

  double val;
  double* rowptr;
  for (unsigned int i = 0; i < n; ++i) {
    val = fac[i];
    rowptr = bm + i * n;
    for (unsigned int j = 0; j < n; ++j)
      rowptr[j] = val * fac[j];
  }

  delete[] fac;
}


/*!
  \param[in] n  Number of pixels along each dimension.  Should be odd
  \param[in] pixsize Size of pixels in arcsec
  \param[in] oversamp Oversampling.  Must be odd
  \param[out] bm Returns beam in row-major order.  Must be pre-allocated by
                   caller and be of length n * n

  The beam is center normalized.  Note that the returned beam is
  always at the nominal sampling.  It's just that if oversampling is
  used this is generated by making a more finely sampled one and then
  repixelating.

  Filtering is not supported
 */
void beam::getRawBeam(unsigned int n, double pixsize, unsigned int oversamp,
		      double* const bm) const {

  //Quick return
  if (oversamp == 1) {
    getRawBeam(n, pixsize, bm);
    return;
  }

  //Input checks
  if (n == 0) {
    std::stringstream errstr;
    errstr << "n (" << n << ") should be positive";
    throw pofdExcept("beam", "getRawBeam", errstr.str(), 1);
  }
  if (n % 2 == 0) {
    std::stringstream errstr;
    errstr << "n (" << n << ") should be odd";
    throw pofdExcept("beam", "getRawBeam", errstr.str(), 2);
  }
  if (pixsize <= 0.0) {
    std::stringstream errstr;
    errstr << "pixsize (" << pixsize << ") should be positive";
    throw pofdExcept("beam", "getRawBeam", errstr.str(), 3);
  }
  if (oversamp == 0) {
    std::stringstream errstr;
    errstr << "oversampling (" << oversamp << ") should be positive";
    throw pofdExcept("beam", "getRawBeam", errstr.str(), 4);
  }
  if (oversamp % 2 == 0) {
    std::stringstream errstr;
    errstr << "oversampling (" << oversamp << ") should be odd";
    throw pofdExcept("beam", "getRawBeam", errstr.str(), 5);
  }
  if (bm == NULL)
    throw pofdExcept("beam", "getRawBeam", "bm is not allocated", 6);

  //Make factorized beam, then multiply and sum
  unsigned int ngen = oversamp * n;
  double pixgen = pixsize / static_cast<double>(oversamp);
  double* fac = new double[ngen];
  double sig = fwhm * pofd_coverage::fwhmfac / pixgen; //Gaussian sigma in pix
  double expfac = - 0.5 / (sig * sig);
  int ni = static_cast<int>(ngen);
  int no2 = ni / 2;
  double dist;
  double normfac = 1.0 / static_cast<double>(oversamp);
  for (int i = 0; i < ni; ++i) {
    dist = fabs(i - no2);
    fac[i] = normfac * exp(expfac * dist * dist);
  }

  // Zero out
  for (unsigned int i = 0; i < n * n; ++i)
    bm[i] = 0.0;

  // Form the sum
  double val;
  double* rowptr;
  unsigned int minip, maxip, minjp, maxjp;
  for (unsigned int i = 0; i < n; ++i) {
    rowptr = bm + i * n;
    minip = i * oversamp;
    maxip = minip + oversamp;
    for (unsigned int i_p = minip; i_p < maxip; ++i_p) {
      val = fac[i_p];
      for (unsigned int j = 0; j < n; ++j) {
	minjp = j * oversamp;
	maxjp = minjp + oversamp;
	for (unsigned int j_p = minjp; j_p < maxjp; ++j_p)
	  rowptr[j] += val * fac[j_p];
      }
    }
  }

  delete[] fac;
}

/*!
  \param[in] n  Number of pixels along each dimension.  Should be odd
  \param[in] pixsize Size of pixels in arcsec
  \param[in] bmpos Beam. Must be pre-allocated by
                   caller and be of length n * n
  \param[in] filter Hi-pass filter to apply.  If null, don't apply filter

  The beam is center normalized.  Note that all spatial information is
  lost by splitting into neg/pos parts
 */
void beam::getBeam(unsigned int n, double pixsize, double* const bm, 
		   hipassFilter* const filter) const {

  // pre-filtered beam
  getRawBeam(n, pixsize, bm);

  // Apply filtering
  if (filter != NULL)
    filter->filter(n, n, bm);
}


/*!
  \param[in] n  Number of pixels along each dimension.  Should be odd
  \param[in] pixsize Size of pixels in arcsec
  \param[in] oversamp Oversampling.  Must be odd
  \param[in] bm Beam. Must be pre-allocated by
                   caller and be of length n * n
  \param[in] filter Hi-pass filter to apply.  If null, don't apply filter

  The beam is center normalized.  
*/
void beam::getBeam(unsigned int n, double pixsize, unsigned int oversamp,
		   double* const bm, hipassFilter* const filter) const {

  // Pre-filtered beam
  getRawBeam(n, pixsize, oversamp, bm);

  // Apply filtering
  if (filter != NULL)
    filter->filter(n, n, bm);
}

////////////////////////////////////////////////

beamHist::beamHist(unsigned int NBINS) : has_data(false), inverse(false), 
					 nbins(0), fwhm(0.0), pixsize(0.0),
					 eff_area(0.0), n_pos(0), n_neg(0) {
  if (NBINS == 0)
    throw pofdExcept("beamHist", "beamHist", "Invalid (non-positive) NBINS", 1);
  nbins = NBINS;
  wt_pos = new unsigned int[nbins];
  bm_pos = new double[nbins];
  wt_neg = new unsigned int[nbins];
  bm_neg = new double[nbins];
}

beamHist::~beamHist() {
  delete[] wt_pos;
  delete[] bm_pos;
  delete[] wt_neg;
  delete[] bm_neg;
}

/*!
  \returns Minimum/Maximum values of positive beam.  If this is the 
  inverse beam, then the minimum/maximum of the inverse positive beam
  are returned.
*/
std::pair<double, double> beamHist::getMinMaxPos() const {
  if (!has_data) 
    return std::make_pair(std::numeric_limits<double>::quiet_NaN(),
			  std::numeric_limits<double>::quiet_NaN());
  if (n_pos == 0) 
    return std::make_pair(std::numeric_limits<double>::quiet_NaN(),
			  std::numeric_limits<double>::quiet_NaN());

  double min, max, val;
  min = max = bm_pos[0];
  for (unsigned int i = 1; i < n_pos; ++i) {
    val = bm_pos[i];
    if (val > max) max = val; else if (val < min) min = val;
  }
  return std::make_pair(min, max);
}

/*!
  \returns Minimum/Maximum values of negative beam.  If this is the 
  inverse beam, then the minimum/maximum of the inverse negative beam
  are returned.
*/
std::pair<double, double> beamHist::getMinMaxNeg() const {
  if (!has_data) 
    return std::make_pair(std::numeric_limits<double>::quiet_NaN(),
			  std::numeric_limits<double>::quiet_NaN());
  if (n_neg == 0) 
    return std::make_pair(std::numeric_limits<double>::quiet_NaN(),
			  std::numeric_limits<double>::quiet_NaN());

  double min, max, val;
  min = max = bm_neg[0];
  for (unsigned int i = 1; i < n_neg; ++i) {
    val = bm_neg[i];
    if (val > max) max = val; else if (val < min) min = val;
  }
  return std::make_pair(min, max);
}

/*!
  \param[in] bm Beam we are getting the histogram for
  \param[in] nfwhm Number of FWHM out we will go on beam
  \param[in] pixsz Pixel size (arcseconds)
  \param[in] filt High pass filter we will apply.  If NULL, don't filter
  \param[in] filtscale Radius of filter region in same units as pixsz
  \param[in] inv Histogram the inverse beam
  \param[in] oversamp Oversampling of beam. Must be odd
*/
void beamHist::fill(const beam& bm, double nfwhm, double pixsz,
		    hipassFilter* const filt, double filtscale, 
		    bool inv, unsigned int oversamp) {

  const double minval = 1e-5; //Always ignore beam values below this

  inverse = inv;
  pixsize = pixsz;
  fwhm = bm.getFWHM();

  // Get how many pixels we will go out
  unsigned int npix = static_cast<unsigned int>(nfwhm * fwhm / pixsize + 
						0.9999999999);
  npix = 2 * npix + 1;

  // Get 2D beam
  // Temporary beam storage.  Must use fftw_malloc since we may filter
  double *bmtmp = (double*) fftw_malloc(sizeof(double) * npix * npix);
  if (filt != NULL) // Set filter scale
    filt->setFiltScale(filtscale / pixsz);
  bm.getBeam(npix, pixsize, oversamp, bmtmp, filt); // Also filters

  // Find effective area
  double val;
  val = bmtmp[0];
  eff_area = val * val;
  for (unsigned int i = 1; i < npix * npix; ++i) {
    val = fabs(bmtmp[i]);
    eff_area += val * val;
  }
  eff_area *= (pixsize * pixsize) / (3600.0 * 3600.0);
  
  // Histogram
  // Find minimum and maximum non-zero parts for neg/pos histograms
  bool has_pos = false;
  bool has_neg = false;
  double minbinval_pos, maxbinval_pos, minbinval_neg, maxbinval_neg;
  minbinval_pos = minbinval_neg = 1e100; // Will definitely never be this large
  maxbinval_pos = maxbinval_neg = -1.0;
  for (unsigned int i = 0; i < npix * npix; ++i) {
    val = bmtmp[i];
    // Ignore anything within [-minval, minval]
    if (val > minval) { // Positive part
      has_pos = true;
      if (val > maxbinval_pos) maxbinval_pos = val;
      if (val < minbinval_pos) minbinval_pos = val;
    } else if (val < -minval) { //Negative part
      val = fabs(val);
      has_neg = true;
      if (val > maxbinval_neg) maxbinval_neg = val;
      if (val < minbinval_neg) minbinval_neg = val;
    }
  }

  // Set bin size
  double histstep_pos, histstep_neg;
  if (has_pos) {
    minbinval_pos = log2(0.999 * minbinval_pos);
    maxbinval_pos = log2(1.001 * maxbinval_pos);
    histstep_pos = (maxbinval_pos - minbinval_pos) / static_cast<double>(nbins);
  } else histstep_pos = 0.0;
  if (has_neg) {
    minbinval_neg = log2(0.999 * minbinval_neg);
    maxbinval_neg = log2(1.001 * maxbinval_neg);
    histstep_neg = (maxbinval_neg - minbinval_neg) / static_cast<double>(nbins);
  } else histstep_neg = 0.0;

  // Actually histogram
  unsigned int idx, utmp;
  unsigned int *tmpwt;
  tmpwt = new unsigned int[nbins];
  double *tmphist;
  tmphist = new double[nbins];

  // Positive histogram
  n_pos = 0;
  for (unsigned int i = 0; i < nbins; ++i) wt_pos[i] = 0;
  for (unsigned int i = 0; i < nbins; ++i) bm_pos[i] = 0.0;
  double lval;
  if (has_pos) {
    for (unsigned int i = 0; i < nbins; ++i)
      tmpwt[i] = 0;
    for (unsigned int i = 0; i < nbins; ++i)
      tmphist[i] = 0.0;
    for (unsigned int i = 0; i < npix * npix; ++i) {
      val = bmtmp[i];
      lval = log2(val);
      if (lval < minbinval_pos) {
	idx = static_cast<unsigned int>((lval - minbinval_pos) / 
					histstep_pos);
	tmphist[idx] += val;
	tmpwt[idx] += 1;
      }
    }
    for (unsigned int i = 0; i < nbins; ++i)
      if (tmpwt[i] > 0) ++n_pos;
    // Shuffle all the filled bins to the front of bm_pos
    idx = 0;
    for (unsigned int i = 0; i < nbins; ++i) {
      utmp = tmpwt[i];
      if (utmp > 0) {
	wt_pos[idx] = utmp;
	bm_pos[idx] = tmphist[i] / static_cast<double>(utmp);
	++idx;
      }
    }
    // Note we histogram in beam space, then invert.  For whatever reason,
    // this seems to work a lot better for P(D)
    if (inverse)
      for (unsigned int i = 0; i < n_pos; ++i)
	bm_pos[i] = 1.0 / bm_pos[i];
  }

  // Negative
  n_neg = 0;
  for (unsigned int i = 0; i < nbins; ++i) wt_neg[i] = 0;
  for (unsigned int i = 0; i < nbins; ++i) bm_neg[i] = 0.0;
  if (has_neg) {
    for (unsigned int i = 0; i < nbins; ++i)
      tmpwt[i] = 0;
    for (unsigned int i = 0; i < nbins; ++i)
      tmphist[i] = 0.0;
    for (unsigned int i = 0; i < npix * npix; ++i) {
      val = fabs(bmtmp[i]);
      lval = log2(val);
      if (lval < minbinval_neg) {
	idx = static_cast<unsigned int>((lval - minbinval_neg) / 
					histstep_neg);
	tmphist[idx] += val;
	tmpwt[idx] += 1;
      }
    }
    for (unsigned int i = 0; i < nbins; ++i)
      if (tmpwt[i] > 0) ++n_neg;
    idx = 0;
    for (unsigned int i = 0; i < nbins; ++i) {
      utmp = tmpwt[i];
      if (utmp > 0) {
	wt_neg[idx] = utmp;
	bm_neg[idx] = tmphist[i] / static_cast<double>(utmp);
	++idx;
      }
    }
    if (inverse)
      for (unsigned int i = 0; i < n_neg; ++i)
	bm_neg[i] = 1.0 / bm_neg[i];
  }
  has_data = true;

  // Clean up
  fftw_free(bmtmp);
}

